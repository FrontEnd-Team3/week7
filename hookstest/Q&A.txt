Q1. 리액트를 사용하는 이유를 설명해보세요 (2가지 이상)
    - 컴포넌트를 재사용할 수 있다.
    - 가상 돔을 통해 상태에 변화가 생겼을 때에만 실제 돔을 변경시킨다.
    - JSX 문법을 사용할 수 있다.
    

Q2. (Q1)을 통해 얻을 수 있는 장점은 무엇일까요?
    - 컴포넌트를 재사용할 수 있으므로 시간을 단축할 수 있다.
    - 가상돔을 통해 필요할 때에만 리렌더링을 발생시킴으로써 성능을 향상시킬 수 있다.
    - HTML과 유사한 문법을 가진 JSX를 JavaScript 내에 바로 쓸 수 있게 하므로 개발자들이 더 쉽게 접근 가능하다.


Q3. 리액트가 가상 돔을 사용하는 이유는 무엇일까요?
    리액트는 성능 향상을 위해 가상 돔을 사용한다. 
    JSX 요소들을 렌더링할 경우 변화는 가상 돔에만 반영이 되고,
    리액트는 'diffing'이라는 과정을 거쳐 이전 버전과 업데이트 된 버전에서 변화된 부분을 찾는다.
    변화된 부분이 있다면, 리액트는 '오직 변경된 부분'만 반영하여 실제 돔을 업데이트한다.
    이처럼 불필요한 돔 조작을 막음으로써 리액트의 가상 돔은 성능을 향상시킬 수 있다. 
    
Q4. 리액트가 가상 돔과 돔 트리를 비교하여 바뀐 부분이 있다면 화면을 다시 그리는 행위를 무엇이라 할까요?
    1) Reconciliation
        : 리액트가 새로운 가상 돔을 이전 버전과 비교하여 업데이트 시 변경된 페이지의 부분이 어디인지 찾아내어 실제 돔을 업데이트하는 과정

    2) Re-rendering
        - 변화를 감지한 데이터를 바탕으로 새로운 UI로 업데이트하는 과정
        - 컴포넌트의 state 또는 props의 변화가 생겼을 때, 리액트는 새로운 데이터를 반영하기 위해 컴포넌트와 그 자식들을 새로 그린다.
        - 이 과정에서 컴포넌트의 'render' 메소드를 호출하는데, 이는 이후 reconciliation 과정에서 사용할 새로운 가상 돔 트리를 생성한다.
        - 변화가 생긴 페이지의 부분만 실제 돔에서 업데이트 된다.

    >> 차이점
        - Rerendering은 컴포넌트의 state 또는 prps에 변화가 생겼을 때 새로운 가상 돔 트리를 생성하는 과정을 말한다.
          이 과정에서 업데이트 된 UI를 반영한 새로운 돔 트리를 생성하는, 컴포넌트의 render 메소드를 호출한다.
        - Reconciliation은 리액트가 새로운 가상 돔 트리와 부합하도록 실제 돔을 업데이트하는 과정을 의미한다.
          이 과정에서, 리액트는 새로운 가상 돔 트리를 이전 버전과 비교하여 업데이트 과정에서 변해야 할 페이지의 부분을 찾아낸다.
          오직 변경된 부분만 실제 돔에서 업데이트되기 때문에, 성능을 향상시킬 수 있는 것이다.
        - Rerendering은 업데이트 된 UI를 나타내는 새로운 가상 돔 트리를 생성하고, Reconciliation은 새로운 가상 돔 트리와 부합하도록 실제 돔을 업데이트한다.

Q5. (Q4)의 행위를 통해 얻을 수 있는 이점은 무엇일까요?
    가상 돔은 실제 화면을 직접 변화시키지 않기 때문에 실제 돔을 조작하는 것보다 훨씬 빠르다.
    코드의 업데이트 또는 수정 사항이 있을 때, 리액트는 가상 돔을 이전 버전과 비교하여
    변경된 부분이 있다면 실제 돔에서 해당 부분만 변경함으로써 
    화면 전체를 다시 그리는 것이 아니라 필요한 부분만 업데이트 할 수 있게 한다.

Q6. (Q4)은 리액트에서 어느 순간에 실현될까요?
    - state 변경이 있을 때
    - props의 값이 업데이트 되었을 때
    - 부모 컴포넌트가 렌더링 되었을 때
    
Q7. 훅 함수는 왜 만들게 되었을까요?
    : 훅 함수를 사용함으로써, class를 사용하지 않고도 state와 생애 주기 메소드 등 리액트의 특징들을 사용할 수 있게 되었다.
    이를 통해 코드를 더 단순하고 명료하고 가독성 좋게 만들 수 있다.
    또한 훅 함수는 props, state, context, refs, lifecycle과 같은 리액트의 개념에 대한 더 직관적인 API를 제공하며,
    컴포넌트 사이의 로직 공유를 더 쉽게 만들어준다.

    아래의 훅 함수는 각 언제 선언되어야 할까요?
    (1) useState
        : 컴포넌트 안에 state를 추가해서 해당 값의 변화가 있을 때마다 rerendering을 발생시킬 필요가 있을 때
    (2) useRef
        - 렌더링을 촉발하지 않는 값을 참조해야 할 때
        - DOM을 조작하고 싶을 때
    (3) useEffect
        - 렌더링에 의해 발생하는 특정한 side effect를 만들고 싶을 때
        - 리액트 state에 기반하여 동기적으로 리액트 밖의 컴포넌트를 통제해야 할 때 (서버 연결 설정, 화면에 컴포넌트가 나타날 때 통계 기록 전송 등)
    (4) useCallback
        : 리렌더링 과정에서 불필요한 콜백 함수의 재선언을 막기 위해 함수 선언을 캐싱하고 싶을 때
    (5) useMemo
        : 리렌더링 과정에서 불필요한 연산 과정을 없애기 위해 계산 결과 값을 캐싱하고 싶을 때

Q8. 커스텀 훅을 제작하면서 얻을 수 있는 이점은 무엇이고 어느 때 만들어야 할까요?
    🤷‍♀️ 언제 만들어야 할까 ?
        - 실제로 그려지는 모습은 다른 여러 컴포넌트 사이에서 동일한 로직을 재사용하고 싶을 때
        - 구현 상태가 아니라 의도를 표현함으로써 불필요한 세부사항을 코드에서 반복하고 싶지 않을 때
        - Effect를 감싸줄 때
            : Effects를 사용한다는 것은 외부의 시스템과 동기화하거나 리액트가 빌트인 API로 가지고 있지 않은 기능을 위해 리액트 밖으로 나감을 의미한다.
              이를 커스텀 훅으로 감싸준다면, 당신의 의도와 데이터가 어떻게 그것을 따라 이동할 지 더욱 명료하게 전달할 수 있다.
              또한 Effect를 커스텀 훅 안에 숨김으로써, 컴포넌트를 작업할 때 불필요한 사항을 의존성 배열에 추가하지 않을 수 있다.
        - 리액트 팀은 커스텀 훅을 통해 앱 속에서 Effects의 개수를 최소한으로 줄이는 것이 목표이다.

    🙆‍♀️ 얻을 수 이점은 무엇일까?
        - 컴포넌트 간 로직을 재사용할 수 있게 함으로써 코드를 더 명료하고 유지보수하기 쉽게 만들어준다.
        - 하나의 함수로 연관된 로직들을 압축(모듈화)하여 코드의 가독성을 향상시킬 수 있다.
        - 컴포넌트로부터 로직을 분리함으로써 코드 검사를 더 쉽게 만들어준다.
        - 새로운 기능이 추가되었을 때, 컴포넌트 자체를 건드리지 않고도 로직 수정이 가능해진다.
            (Effect로써 구현한 것을 가능케하는 새로운 기능이 추가되었을 때, 컴포넌트를 수정하지 않고도 Effect를 제거할 수 있다.)

Q9. 리액트로 프로젝트를 만들려고할 때 고려해야하는 사항들을 아는대로 작성해보세요 (3가지 이상)
    1) 어떤 툴과 프레임워크를 사용할 지
        - Next.js, Gatsby, Remix, ...
        - Node.js나 npm/yarn 같은 패키지 관리 툴
    2) 구현을 위해 필요한 라이브러리에는 어떤 것들이 있을지
        - React-Router-DOM, Styled-components, ...
    3) 어떻게 명료하고 논리적인 폴더 구조를 구성할 수 있을지
        - 필요한 파일을 편리하게 찾아서 사용할 수 있도록 앱의 다양한 부분을 적절하게 나누는 방법을 고민해볼 것

Q10. 만약 위의 질문에 모두 답을 했다면, 현재 부족한 것은 리액트가 아닌 자바스크립트 일 수 있습니다
     이전 풀어보았던 자바스크립트 API 문제 1~4와 board 문제를 현재 풀이할 수 있는지 확인해보세요
    
    react로 풀이를 한다고 가정했을 때와 (직접 바꿔보지는 말 것, 예제 문제와 유사)
    vanilla js(java script)로 풀이한다고 하였때 와의 차이점은 무엇일까요?

    * 위 문제를 받지 못한 수강생은 메일 전송 시 따로 첨부하여 송부

    - vanilla js에서는 각 요소들의 기능을 구현하기 위해서는 DOM에 직접 접근하여 해당 요소를 가져오고,
      직접 addEventListener을 사용하여 클릭 시 발생할 이벤트를 달아주어야 했다.
    - 반면 React.js를 사용하면 DOM을 직접 조작하지 않고도 style과 이벤트 등을 구현한 컴포넌트를 사용함으로써
      해당 로직을 별도의 파일로 분리하여 재사용할 수 있다.
    - 예를 들어, 하나의 버튼을 구현한다고 했을 때, vanilla js에서는 매번 해당 버튼을 DOM에서 가져와야 했지만
      React.js에서는 버튼 컴포넌트를 페이지에 import 함으로써 하나의 버튼을 계속 재사용할 수 있다.
      이를 통해 코드를 더 단순하고 구조적으로 만들 수 있다.
    
Q11. 리액트에서 컴포넌트를 나누는 기준은 어떻게 되어야할까요?
     또한, 이러한 관점은 개발자마다 다를 수 있는데 왜 그럴까요?
     - 가장 중요한 것은 진행 중인 프로젝트의 규모와 복잡도, 개인의 선호에 기반하여 컴포넌트를 나눌 기준을 선택하는 것이다.
     - 리액트의 프로젝트를 구성하는 데 있어 획일화된 방식이 없고,
       앞서 언급한 것처럼 프로젝트에 따라, 또 개발자 개인 또는 팀의 선호도에 따라 최적의 폴더 구조는 다르기 때문에
       컴포넌트를 나누는 기준이 개발자마다 다를 수 있다.
