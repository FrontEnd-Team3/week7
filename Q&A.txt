Q1. 리액트를 사용하는 이유를 설명해보세요 (2가지 이상)
    - 리액트는 가상 돔(Virtual DOM)을 사용하여 성능을 최적화하고, 효율적인 UI 업데이트를 가능하게 합니다.
    - 컴포넌트 기반 아키텍처를 제공하여 코드의 재사용성과 유지 보수성을 높일 수 있습니다.
    - 리액트는 단방향 데이터 흐름을 따르므로 상태 관리가 간단하고 예측 가능합니다.
    - 커뮤니티와 생태계가 활발하여 다양한 라이브러리와 도구를 활용할 수 있습니다.
    

Q2. (Q1)을 통해 얻을 수 있는 장점은 무엇일까요?
    - 가상 돔을 사용하여 효율적인 UI 렌더링을 할 수 있어 성능이 향상됩니다.
    - 컴포넌트 기반 아키텍처를 사용하므로 코드의 재사용성과 유지 보수성이 높아집니다.
    - 상태 관리가 예측 가능하고 디버깅이 용이합니다.
    - 활발한 커뮤니티와 생태계로 다양한 지원과 도구를 활용할 수 있습니다.


Q3. 리액트가 가상 돔을 사용하는 이유는 무엇일까요?
    - 가상 돔을 사용하여 효율적인 UI 렌더링을 할 수 있어 성능이 향상됩니다.
    - 컴포넌트 기반 아키텍처를 사용하므로 코드의 재사용성과 유지 보수성이 높아집니다.
    - 단방향 데이터 흐름으로 인해 상태 관리가 예측 가능하고 디버깅이 용이합니다.
    - 활발한 커뮤니티와 생태계로 다양한 지원과 도구를 활용할 수 있습니다.

Q4. 리액트가 가상 돔과 돔 트리를 비교하여 바뀐 부분이 있다면 화면을 다시 그리는 행위를 무엇이라 할까요?
    - 가상 돔과 실제 돔 트리를 비교하여 바뀐 부분을 찾고, 해당 부분을 실제 돔에 반영하는 것을 "리렌더링"이라고 합니다.


Q5. (Q3)의 행위를 통해 얻을 수 있는 이점은 무엇일까요?
    - 리랜더링의 이점은 리액트의 성능을 향상시킵니다. 변경된 부분만을 감지하여 업데이트하기 때문에 불필요한 작업을 줄이고 효율적인 렌더링을 할 수 있습니다.


Q6. (Q3)은 리액트에서 어느 순간에 실현될까요?
    - 리랜더링은 리액트의 렌더링 과정 중 "조화 과정"에서 실현됩니다. 가상 돔과 실제 돔 트리를 비교하여 변경된 부분을 찾아 업데이트합니다.

Q7. 훅 함수는 왜 만들게 되었을까요?
    아래의 훅 함수는 각 언제 선언되어야 할까요?
    - 훅 함수는 리액트 함수형 컴포넌트에서 상태 관리와 부작용(effect) 처리를 간편하게 하기 위해 만들어졌습니다.
    (1) useState: 컴포넌트에서 상태를 관리할 때 사용하며, 컴포넌트 내부의 최상위에서 선언되어야 합니다.
    (2) useRef: 컴포넌트에서 가변적인 값을 유지하고 싶을 때 사용하며, 컴포넌트 내부의 최상위에서 선언되어야 합니다.
    (3) useEffect: 컴포넌트의 부작용(effect)을 처리하고, 외부 데이터를 가져오거나 구독할 때 사용하며, 컴포넌트 내부의 최상위에서 선언되어야 합니다.
    (4) useCallback: 컴포넌트가 렌더링될 때마다 함수가 새로 생성되는 것을 방지하기 위해 사용하며, 필요한 경우에만 선언되어야 합니다.
    (5) useMemo: 계산 비용이 많은 함수의 반환 값을 기억하고 재사용하기 위해 사용하며, 필요한 경우에만 선언되어야 합니다.
    

Q8. 커스텀 훅을 제작하면서 얻을 수 있는 이점은 무엇이고 어느 때 만들어야 할까요?
    - 커스텀 훅을 제작하면 관련된 로직을 재사용하고 코드를 모듈화할 수 있습니다. 이를 통해 코드의 가독성과 유지 보수성이 향상됩니다.
    - 커스텀 훅은 React 컴포넌트에서 상태 관리, 라이프사이클 이벤트 처리, 데이터 가져오기 등의 작업을 추상화하고 재사용 가능한 형태로 만들 수 있습니다. 커스텀 훅은 주로 비즈니스 로직을 추상화하고 컴포넌트의 역할을 단순화하는 데 사용됩니다. 일반적으로, 커스텀 훅은 다른 컴포넌트에서도 재사용될 가능성이 있는 로직을 분리하여 작성하는 것이 좋습니다.


Q9. 리액트로 프로젝트를 만들려고할 때 고려해야하는 사항들을 아는대로 작성해보세요 (3가지 이상)
    - 프로젝트 구조: 리액트 프로젝트를 시작하기 전에 프로젝트의 구조를 설계해야 합니다. 어떤 컴포넌트를 사용할지, 상태 관리를 어떻게 할지, 라우팅을 어떻게 설정할지 등을 고려해야 합니다.
    - 상태 관리: 대규모 프로젝트의 경우 상태 관리를 위한 라이브러리인 Redux나 MobX 등을 고려할 수 있습니다. 작은 규모의 프로젝트에서는 React의 내장 상태 관리 기능인 useState, useEffect 등을 사용할 수 있습니다.
    - 성능 최적화: 리액트 앱은 가상 DOM을 사용하여 성능을 최적화합니다. 그러나 대규모 앱이나 성능이 중요한 앱에서는 React.memo, useMemo, useCallback 등을 사용하여 컴포넌트의 리렌더링을 최소화해야 합니다.

Q10. 만약 위의 질문에 모두 답을 했다면, 현재 부족한 것은 리액트가 아닌 자바스크립트 일 수 있습니다
    이전 풀어보았던 자바스크립트 API 문제 1~4와 board 문제를 현재 풀이할 수 있는지 확인해보세요
    
    react로 풀이를 한다고 가정했을 때와 (직접 바꿔보지는 말 것, 예제 문제와 유사)
    vanilla js(java script)로 풀이한다고 하였때 와의 차이점은 무엇일까요?

    * 위 문제를 받지 못한 수강생은 메일 전송 시 따로 첨부하여 송부

    - 구성 요소 기반 접근: 리액트는 컴포넌트 기반의 라이브러리이므로, 문제를 리액트로 푸는 경우 컴포넌트를 생성하고 조합하여 문제를 해결하는 방식으로 접근합니다. 반면에 바닐라 자바스크립트로 문제를 푸는 경우에는 리액트의 컴포넌트 기능을 사용할 수 없으므로, 함수나 객체 등의 기본 자바스크립트 요소를 활용하여 문제를 해결해야 합니다.
    - 상태 관리: 리액트는 상태 관리를 위해 내장된 상태 관리 기능인 useState, useContext 등을 사용합니다. 이를 활용하여 컴포넌트의 상태를 관리하고 업데이트할 수 있습니다. 하지만 바닐라 자바스크립트에서는 상태 관리를 위해 추가적인 로직을 구현해야 합니다. 예를 들어, 전역 변수를 사용하거나 상태 변경을 위한 직접적인 메서드를 구현해야 할 수 있습니다.
    - 가상 DOM 및 리렌더링: 리액트는 가상 DOM을 사용하여 성능을 최적화합니다. 변경된 부분만 리렌더링하여 DOM 조작을 최소화하고 성능을 향상시킵니다. 이에 반해 바닐라 자바스크립트에서는 직접 DOM 조작을 해야 하므로, 변화된 부분을 수동으로 감지하고 업데이트하는 로직을 작성해야 합니다. 이로 인해 코드의 복잡성이 증가할 수 있습니다.
    

Q11. 리액트에서 컴포넌트를 나누는 기준은 어떻게 되어야할까요?
     또한, 이러한 관점은 개발자마다 다를 수 있는데 왜 그럴까요?

     리액트에서 컴포넌트를 나누는 기준은 개발자마다 다를 수 있습니다. 일반적으로는 다음과 같은 기준을 고려할 수 있습니다:
     단일 책임 원칙: 컴포넌트는 한 가지 역할이나 책임을 가지고 있어야 합니다. 기능이나 로직이 서로 다른 부분은 분리하여 개별 컴포넌트로 만들어 유지 관리하기 쉽도록 합니다.
     재사용성: 여러 곳에서 반복적으로 사용되는 로직이나 UI 요소는 재사용 가능한 컴포넌트로 분리합니다. 이렇게 분리된 컴포넌트는 다른 프로젝트나 다른 부분에서 쉽게 재사용할 수 있습니다.
     가독성: 컴포넌트는 읽기 쉽고 이해하기 쉬운 구조로 작성되어야 합니다. 관련된 기능이나 UI 요소는 함께 그룹화하여 한 눈에 파악할 수 있도록 합니다.
     성능 최적화: 리액트는 가상 DOM(Virtual DOM)을 사용하여 성능을 최적화합니다. 컴포넌트를 세분화하고 필요한 부분만 리렌더링되도록 분리하여 성능을 향상시킬 수 있습니다.
     이러한 기준은 개발자의 경험과 프로젝트의 복잡성, 요구사항에 따라 다를 수 있습니다. 